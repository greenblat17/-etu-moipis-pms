

# **1\. Анализ исходных данных.** 

В работе разрабатывается каркас подсистемы описания и исполнения процессов: классификатор процессов, шаблоны процессов (состояния, решения, переходы, права доступа), формирование экземпляров процессов по шаблонам и исполнение процессов с фиксацией траектории. В качестве предметной области выбран маркетплейс (каталог товаров). В качестве исходных данных используются два процесса, представленные в виде диаграмм состояний.

Рис. 1\. Диаграмма состояний процесса “Включение нового товара в каталог”

Рисунок 1 описывает жизненный цикл карточки товара при первичном заведении в каталог. Процесс стартует с формирования **черновика** и далее имеет обязательную ветку **модерации** (контроль качества/соответствия правилам). По результатам модерации возможны три исхода: **одобрение** (переход в “Опубликован”), **запрос правок** (переход в “Запрошены правки” с возвратом в “Черновик” после исправлений) или **отклонение** (конечное состояние).

Также на диаграмме показаны ветки управления жизненным циклом после публикации: **приостановка** (временная пауза) и **архивирование** (завершение размещения). Отдельно предусмотрено **завершение по инициативе исполнителя процесса** (отмена) до публикации.

Рис. 2\. Диаграмма состояний процесса “Управление изменениями карточки товара”.

Рисунок 2 показывает, что изменение карточки товара выполняется не “наживую”, а через подготовку изменения: сначала происходит **выбор товара** и **создание копии** (версия/черновик изменений), затем — **редактирование параметров**. После редактирования изменения проходят **двухступенчатое согласование**: проверка модератором и проверка руководителем (или владельцем категории).

От обеих стадий согласования предусмотрена ветка “на доработку” (возврат к редактированию). После согласования формируется решение “разрешить ввод изменений” с альтернативой “отложить”: это отражает типичную ситуацию, когда изменение согласовано, но применяется позже. Завершение процесса наступает после “ввода изменений в действие” и фиксации состояния “изменение введено”.

Рис. 3\. Модель для поддержки процессов примера

Модель фиксирует, на какой “объект” навешиваются процессы, и какие данные при этом меняются. Базовая сущность — **товар**. Его параметры описываются справочником **параметров** (например, “цвет”, “размер”), а фактические значения параметров конкретного товара хранятся в связующей сущности “значение параметра товара”.

Процесс 1 “включение нового товара” привязан к товару как к основной сущности (создание/модерация/публикация карточки). Процесс 2 “управление изменениями карточки” в своей сути приводит к изменениям записей значений параметров товара (и поэтому связан с сущностью значений параметров).

# **2\. Разработка функциональных требований к подсистеме**

Для разработки концептуального проекта будем использовать редактор PlantUML.

Рис. 4\. Структура прецедентов для поддержки процессов.

Диаграмма разделяет функции подсистемы на две части.

**Конструктор процессов** отвечает за подготовку спецификаций: описание логики процесса (состояния, переходы, навигация, деятельность в состоянии) и описание локальной модели классов процесса. Это покрывает требование “формирование шаблонов процессов”.

**Исполнитель процессов** использует подготовленные спецификации: создаёт экземпляры процессов по шаблонам, управляет движением процессов по траектории и выполняет действия в текущем состоянии. Это покрывает требования “формирование экземпляров” и “исполнение процессов”.

# **3\. Разработка проектной модели классов** 

Рис. 5\. Модель типового процесса (шаблон, состояния, решения, доступы).

На рисунке 5 показана основная идея каркаса: **типовой процесс** описывает поведение один раз и затем используется многократно. Типовой процесс связан с классом товара (для каких товаров применим шаблон) и содержит состав допустимых **состояний процесса**. Каждое состояние имеет “тип состояния” (справочник), а признак flagBeg определяет начальное состояние.

Для каждого состояния задаётся список **допустимых решений** (какие действия можно выбирать в этом состоянии). Дополнительно задаются **права доступа**: какие группы пользователей имеют доступ к состояниям и к решениям. Тем самым шаблон описывает не только “граф переходов”, но и правила участия пользователей в исполнении.

Рис. 6\. Модель для поддержки спецификации правил перехода

Рисунок 6 показывает, как описывать правила переходов в виде **сторожевых условий**. Для конкретной позиции траектории известны текущее состояние и принятое решение. Чтобы определить допустимость/следующий переход, вычисляется предикативная функция, которая опирается на набор предикатов.

Условия представлены в виде **ДНФ** (дизъюнкции конъюнкций): “формула” хранит структуру связок, а “предикат” — атомарную проверку (например, по состоянию, по решению или по результатам контроля параметров). Такой подход позволяет хранить логику переходов как данные и изменять её без переписывания кода.

Рис. 7\. Исполнитель процессов (экземпляр процесса и траектория).

На рисунке 7 показано, как из шаблона получается выполняемый экземпляр. Сущность “процесс” (process) ссылается на **типовой процесс** (type\_process) и на конкретный **товар** (prod). Движение процесса по состояниям фиксируется таблицей “траектория” (trajctory): каждая позиция содержит номер шага num\_pos, текущее состояние (type\_state), выбранное решение (type\_decision) и данные об исполнителе (person) с отметкой времени.

Это обеспечивает требование задания “исполнение процессов” и “ведение траектории движения”: по таблице траектории можно восстановить историю решений и текущее состояние процесса.

# **4\. Разработка модели хранения**

Рис. 8\.  Модель хранения для ведения данных о товарах  
На рисунке 8 показана локальная модель хранения предметной области: товар (prod) принадлежит классу товара (chem\_class). Параметры описываются справочником (parametr), а значения параметров конкретного товара хранятся в связующей таблице (par\_prod).

Таблица par\_class позволяет задавать ограничения параметров на уровне класса товара (например, допустимый диапазон значений), что используется при контроле корректности параметров и может участвовать в сторожевых условиях переходов.

Рис. 9\. Модель хранения для описания структуры процессов

Диаграмма описывает метаданные шаблона процесса:

* type\_process — справочник типовых процессов (название, краткое имя, связь с классом товара);

* state — состав состояний в конкретном типовом процессе (включая признак начального состояния);

* type\_state — справочник типов состояний;

* type\_decision — справочник типовых решений;

* decision\_map — список допустимых решений в конкретном состоянии процесса.

Разграничение доступа на уровне групп пользователей представлено сущностями gr\_person и access\_state: они задают, какие группы могут участвовать в выполнении процесса в конкретных состояниях.

Рис. 10\. Модель хранения для описания траектории движения процессов

Диаграмма показывает, как хранится исполнение:

* process — экземпляры процессов (какой типовой процесс запущен и для какого товара);

* trajctory — история шагов выполнения (номер позиции, состояние, решение, пользователь, время).

Ссылки на type\_state и type\_decision обеспечивают “читаемость” траектории через справочники, а ссылка на person фиксирует, кто именно принял решение на каждом шаге. Такой способ хранения позволяет строить отчёт “траектория процесса” одной выборкой.

Рис. 11\. Модель хранения для описания логики переходов

Диаграмма описывает хранение сторожевых условий как данных:

* funct — справочник функций условий (какое условие привязано к состоянию);

* predicat — атомарные предикаты, которые могут ссылаться на состояние и/или решение (и при необходимости — на результат контроля параметров);

* formula — структура ДНФ: набор дизъюнктов (num\_dis) и конъюнктов (num\_con), связывающих предикаты.

В типовом процессе конкретному состоянию может быть назначена функция условия, которая и используется для проверки возможности перехода/выбора решения.

